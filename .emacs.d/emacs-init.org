
* Basics

** Always rebuild init and refresh package cache

#+begin_src emacs-lisp
(use-package emacs
  :config
  (defun prot/delete-emacs-init ()
    (interactive)
    (let ((configs "~/.emacs.d/emacs-init.el"))
      (when configs
        (delete-file configs))))
  :hook ((kill-emacs-hook . prot/delete-emacs-init)
         (kill-emacs-hook . package-quickstart-refresh)))
#+end_src

** Remove modeline "lighters

#+begin_src emacs-lisp
(use-package diminish
  :ensure
  :after use-package)
#+end_src

** Put customisation settings in a "custom.el"
When you install a package or use the various customisation interfaces
to tweak things to your liking, Emacs will append a piece of elisp to
your init file.  I prefer to have that stored in a separate file.

Note that a common source of inconsistencies with configurations arises
from a conflict between your code and what is stored in the =custom=
snippet.  When something does not seem to work as intended, make sure to
check =custom.el= and edit or delete it if necessary (if deleted, it will
be created again the next time you start Emacs).

#+begin_src emacs-lisp
(use-package cus-edit
  :config
  (setq custom-file "~/.emacs.d/custom.el")

  (unless (file-exists-p custom-file)
    (write-region "" nil custom-file))

  (load custom-file))
#+end_src

** Fundamentals for Hydras
   :PROPERTIES:
   :CUSTOM_ID: h:af691a31-917e-4d9b-aee6-5744b1173999
   :END:

A "hydra" is an ad-hoc mode for mapping commands to a group of more
convenient key bindings.  In an active hydra, all of its keys---the
hydra's "heads"---can be typed in any order, keeping the mode active in
the process (if wanted), while at least one key performs the function of
exiting the hydra.

In practice, *I do not use hydras as substitutes for mode maps*.  Instead,
I treat them as complementary to minor modes that offer enhancements to
a particular major mode but are otherwise not very useful outside that
niche.  Think of cases such as a code linter (the minor mode) as part of
a programming session (major mode).

The reason I use hydras this way is due to the official key binding
conventions that I [generally] follow (as documented in the Emacs
manual).  The idea of using =C-c [a-z]= for all these minor modes is good
only if you have a few of them and only if they are more useful outside
a particular task.  In other words, it does not scale.

I thus employ =C-c h= as a common prefix for all my hydras (knowing that
it is meant for private use), binding each sequence to the relevant
minor mode's map.  An extra key completes the chord following mnemonics.
For instance, a hydra about the linter when that is active is =C-c h l=,
for the outline viewer =C-c h o=, for git merge conflicts =C-c h g=, and so
on.

Look for the =defhydra= macro in the relevant package declarations (these
will evolve over time).  Hydras are colour-coded as a means of denoting
their behaviour with regard to the use of non-defined keys and the
criteria for exiting.

| Colour   | Hydra heads         | Other keys          |
|----------+---------------------+---------------------|
| red      | Accept and Continue | Accept and Exit     |
| pink     | Accept and Continue | Accept and Continue |
| amaranth | Accept and Continue | Reject and Continue |
| teal     | Exit                | Reject and Continue |
| blue     | Exit                | Accept and Exit     |

Also check [[https://github.com/abo-abo/hydra][the project's source]] for more information.

;#+begin_src emacs-lisp
(use-package hydra :ensure)
#+end_src

** scralling

#+begin_src emacs-lisp
;; scroll one line at a time (less "jumpy" than defaults)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ; one line at a time
(setq mouse-wheel-progressive-speed nil)            ; don't accelerate scrolling
(setq-default smooth-scroll-margin 0)
(setq scroll-step 1
      scroll-margin 1
      scroll-conservatively 100000)
#+end_src
* Interface and interaction
** IT and theme

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (menu-bar-mode -1)
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (show-paren-mode 1)
    (delete-selection-mode 1)
    (save-place-mode 1)
    (global-visual-line-mode 1)
    :config
    (setq message-directory "~/.emacs.d/mail/")
    (setq gnus-directory "~/.emacs.d/news/")
    (setq nnfolder-directory "~/.emacs.d/mail/archive")
    (setq use-file-dialog nil)
    (setq use-dialog-box nil)
    (setq inhibit-splash-screen t)
    (setq-default truncate-lines t)
    (global-unset-key (kbd "C-z"))
    (global-unset-key (kbd "C-x C-z"))
    (global-unset-key (kbd "C-h h")))
    ;(require 'multi-term)
    ;(setq multi-term-program "/bin/bash")
    (setq auto-save-default nil)  ;; stop creating those #auto-save# files
    (setq make-backup-files nil)
    (setq create-lockfiles nil)

#+end_src

** Set short yes and no

#+begin_src emacs-lisp
  (set-default 'curser-type 'hbar)
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** Scrolling

#+begin_src emacs-lisp
(use-package smooth-scroll
:ensure t)
#+end_src

** Add font

#+begin_src emacs-lisp
(set-face-attribute 'default nil
                    ;;:family "Comic regular"
                    :family "Fira Code Retina"
                    :height 120
                    :weight 'normal
                    :width 'normal)
;(add-to-list 'default-frame-alist
;	    '(font . " Comic regular "))
	    	    ;; '(font . "Agave  "))
;;              Comic Relief 120
  ;;font zoom
    (define-globalized-minor-mode
      global-text-scale-mode
     // text-scale-mode
      (lambda () (text-scale-mode .2)))

     (defun global-text-scale-adjust (inc) (interactive)
      (text-scale-set .2)
      (kill-local-variable 'text-scale-mode-amount)
      (setq-default text-scale-mode-amount (+ text-scale-mode-amount inc))
      (global-text-scale-mode .2)
    )
    (global-set-key (kbd "M-0")
		    '(lambda () (interactive)
		       (global-text-scale-adjust (- text-scale-mode-amount))
		       (global-text-scale-mode -.2)))
    (global-set-key (kbd "M-<up>")
		    '(lambda () (interactive) (global-text-scale-adjust .2)))
    (global-set-key (kbd "M-<down>")
		    '(lambda () (interactive) (global-text-scale-adjust -.2)))

  ;;auto scaling at startup increases the fontsize
;    (global-text-scale-adjust .2)
#+end_src
** Scratch buffer

#+begin_src emacs-lisp
(setq initial-scratch-message
         ";; Chant and be happy!\n")
#+end_src
** Which-key
#+begin_src emacs-lisp

(use-package which-key
:ensure t
:config (which-key-mode))

#+end_src
** Dired

#+begin_src emacs-lisp
(require 'dired-x)			   ; require additional functionality for dired ;
(add-hook 'dired-mode-hook                 ; when running dired-mode t
** completion

;;-->#+BEGIN_SRC emacs-lisp
 (use-package auto-complete
 :ensure t
:init
(progn
(ac-config-default)
(global-auto-complete-mode t)
(add-to-list 'ac-modes 'org-mode)
 (ac-set-trigger-key "TAB")
))


#+END_SRC

** Transparancy

#+BEGIN_SRC emacs-lisp
 (set-frame-parameter (selected-frame) 'alpha '(97 . 97))
 (add-to-list 'default-frame-alist '(alpha . (97 . 97)))
#+END_SRC

** E-reader

#+BEGIN_SRC emacs-lisp
;;nov-mode
;;ereader-mode
#+END_SRC

** Theme settings

#+begin_src emacs-lisp
     (use-package emacs
     :init
     (defun kk/theme-light ()
     (interactive)
     (load-theme 'tsdh-light t)
     (set-face-background 'mode-line "#F7F2C5")
     (set-face-background 'mode-line-inactive "#FCFCFB")))

     ;;set the light theme with a yellow mode-line
     (load-theme 'gruvbox-light-medium t)

     (defun kk/reset-mode-color ()
     "rest mode-line color to white back"
     (interactive)
     (set-face-background 'mode-line "#FFFFFF")
     (set-face-background 'mode-line-inactive "#FFFFFF"))

(defun set-background-for-terminal (&optional frame)
  (or frame (setq frame (selected-frame)))
  "unsets the background color in terminal mode"
  (unless (display-graphic-p frame)
    (set-face-background 'default "unspecified-bg" frame)))
(add-hook 'after-make-frame-functions 'set-background-for-terminal)
(add-hook 'window-setup-hook 'set-background-for-terminal)

#+end_src
** Windoes rules
*** Split windows

#+begin_src emacs-lisp

(defun kk/split-horizontal ()
"Split a window and open Ibuffer to the next window"
(interactive)
(split-window-vertically)
(other-window '1)
(ibuffer))

(global-set-key (kbd "C-x 2")
'(lambda () (interactive)
(kk/split-horizontal)))

(defun kk/split-vertical ()
"Split a window and open the Ibuffer to the next window"
(interactive)
(split-window-horizontally)
(other-window '1)
(ibuffer))

(global-set-key (kbd "C-x 3")
'(lambda () (interactive)
(kk/split-vertical)))

#+end_src

*** Swapping windows

#+begin_src emacs-lisp
(defun kk/swap-buffers-in-windows ()
  "Put the buffer from the selected window in next window, and vice versa"
  (interactive)
  (let* ((this (selected-window))
     (other (next-window))
     (this-buffer (window-buffer this))
     (other-buffer (window-buffer other)))
    (set-window-buffer other this-buffer)
    (set-window-buffer this other-buffer)
    )
  )
 #+end_src

** Terminals
#+begin_src emacs-lisp 

;;  (global-set-key (kbd "<s-return>")
 ;; '(lambda () (interactive)
 ;; (multi-term)))
;;
 ;; (defun kk/new-shell ()
   ;;   "creates a shell with a given name"
   ;;   (interactive);; "Prompt\n shell name:"
   ;;   (let ((shell-name (read-string "shell name: " nil)))
    ;;  (shell (concat "*" shell-name "*"))
    ;;  (delete-other-windows )))

 ;; (fset 'menu-bar-open nil)

  ;;disable the popup-menu called from an exidentle mouse-1

  (global-set-key (kbd "C-c c") 'shell)

#+end_src
** Mouse and  Popup

#+begin_src emacs-lisp
 
(require 'disable-mouse)
;(global-disable-mouse-mode)

(defun kk/mouse-enable-disabel()
(interactive)
(global-disable-mouse-mode))

(global-set-key (kbd "<C-down-mouse-1>")
'(lambda () (interactive)
(down-mouse-1)))

#+end_src

** Mode-history
#+begin_src emacs-lisp
(setq savehist-file "~/.emacs.d/savehist")
(setq savehist-additional-variables
      '(buffer-name-history
        compile-command
        extended-command-history
        file-name-history
        kill-ring
        regexp-search-ring
        search-ring))
	'(save-place-limit 200)
	(savehist-mode 1)
#+end_src
** modeline feebleline
#+begin_src emacs-lisp

(use-package    feebleline
  :ensure       t
  :config       (setq feebleline-msg-functions
                      '((feebleline-line-number         :post "" :fmt "%5s")
                        (feebleline-column-number       :pre ":" :fmt "%-2s")
                        (feebleline-file-directory      :face feebleline-dir-face :post "")
                        (feebleline-file-or-buffer-name :face font-lock-keyword-face :post "")
                        (feebleline-file-modified-star  :face font-lock-warning-face :post "")
                        (feebleline-git-branch          :face feebleline-git-face :pre " : ")
                        (feebleline-project-name        :align right)))
                (feebleline-mode 1))

#+end_src
** pdf tools
#+begin_src emacs-lisp

  (use-package pdf-tools
    :load-path "site-lisp/pdf-tools/lisp"
    :magic ("%PDF" . pdf-view-mode)
    :ensure t 
    :config
    (pdf-tools-install :no-query)
  (setq-default pdf-view-display-size 'fit-page)
     :bind (:map pdf-view-mode-map
	   ("\\" . hydra-pdftools/body)
	   ("<s-spc>" .  pdf-view-scroll-down-or-next-page)
	   ("g"  . pdf-view-first-page)
	   ("G"  . pdf-view-last-page)
	   ("l"  . image-forward-hscroll)
	   ("h"  . image-backward-hscroll)
	   ("j"  . pdf-view-next-page)
	   ("k"  . pdf-view-previous-page)
	   ("e"  . pdf-view-goto-page)
	   ("u"  . pdf-view-revert-buffer)
	   ("al" . pdf-annot-list-annotations)
	   ("ad" . pdf-annot-delete)
	   ("aa" . pdf-annot-attachment-dired)
	   ("am" . pdf-annot-add-markup-annotation)
	   ("at" . pdf-annot-add-text-annotation)
	   ("y"  . pdf-view-kill-ring-save)
	   ("i"  . pdf-misc-display-metadata)
	   ("s"  . pdf-occur)
	   ("b"  . pdf-view-set-slice-from-bounding-box)
	   ("r"  . pdf-view-reset-slice))) 

#+end_src
* Vim integation
#+begin_src emacs-lisp

(use-package evil
  :ensure t ;; install the evil package if not installed
  :init ;; tweak evil's configuration before loading it
  (setq evil-search-module 'evil-search)
  (setq evil-ex-complete-emacs-commands nil)
  (setq evil-vsplit-window-right t)
  (setq evil-split-window-below t)
  (setq evil-shift-round nil)
  (setq evil-want-C-u-scroll t)
  :config ;; tweak evil after loading it
  (evil-mode))

#+end_src

* Version control tools
** Generic version control (VC) framework

VC is a generic framework that works with several version control
systems, else "backends".  In practice though, I only ever use it with
=git=.  Compared with =magit= (see section on [[#h:76d1b392-e693-40dc-b320-d4c1047115ab][Magit configs]]), =vc= offers a
more abstract, buffer-oriented workflow that, I feel, covers all common
version control cases.

With VC we can track and ignore files, commit changes, view diffs and
logs, push and pull from a remote…  Everything you would expect from a
version control system.  But I am not sure it is possible or convenient
to perform tasks such as staging only a particular part of a diff,
handling multiple remotes, interactively rebasing the commit log, etc.

As such, I employ VC as my generalist interface to the most common Git
interactions: diffs, commits, logs.  While I rely on Magit for expedient
access to the more advanced features of Git, all of which are rendered
approachable through an interactive/modal interface.

I started using VC with this a common scenario: to produce a diff of my
current changes formatted as a ready-to-apply patch.  This is done with
=vc-diff= (also see the =vc-git-diff-switches= variable).  A diff hunk can
be applied while in the =*vc-diff*= buffer by hitting =C-c C-a=.  Fairly
easy.  One can always save the diff buffer using the standard =C-x C-w=
command (=write-file=).  Use these to send patches (e.g. via email),
without having to go through proprietary web tools.

Another nice feature is a region-specific commit log with =C-x v h=
(=vc-region-history=).  Highlight a region and run the command to get a
clear view of how it took form.  Quite an easy way to "git blame".  For
a more macroscopic view of the file's entire history you can always rely
on =C-x v g= or my alias =C-x v a= which calls =vc-annotate=.  Commits are
colour-coded with those on the red side of the spectrum being the newest
ones, while those on the blue end representing the older ones.

=C-x v v= (=vc-next-action=) is a hidden gem: a paradigm of minimalism done
right.  On a new project it will first ask you for a backend.  Selecting
=git= will run =git init=.  Invoking the command again will track the file
and commit the changes.  If the file is already being tracked, it will
just proceed to the next step.  It always follows a logical sequence
which translates into a powerful metaphor of going through the process
of committing changes to files.

The commit buffer presents you with a summary section followed by the
body of the commit message, separated by an empty line (shown as a
border) as per the conventions that govern good commit messages.  In the
lower part you can see the affected files (just the current file by
default).  The standard =C-c C-c= confirms the commit, while =C-c C-k=
cancels it.  Furthermore, there is =C-c C-f= to view the file set
concerned (in case it is not already visible below the message area), as
well as =C-c C-d= to produce a diff of what is being committed.

You can review the commit log for the current file with =C-x v l=
(=vc-print-log=) or for the entirety of the current project with =C-x v L=
(=vc-print-root-log=).  From there you can display any diff with =d= or find
the prior state of the commit at point with =f=.  Use the latter as a
starting point for reverting to a prior state.  Also note that while
inside the root log view, you can use an active region to show diffs in
that range of commits.

With =vc-dir=, which I rebind to the more logical "project" mnemonic of
=C-x v p= (=prot/vc-dir-project=), you can mark with =m= several files to add
to a commit.  Use =M= to mark all files with the same status.  This mode
offers easy access to the standard VC actions.  To commit the file at
point or the marked ones hit =v=.  To push do =P=.  Same principle for
diffs, logs, etc.

By the way, rebinding =vc-dir= has another upside of allowing its original
key binding to be assigned to =vc-diff=; which in turn makes that
mnemonically consistent with the =C-x v D= sequence, else =vc-root-diff=
(make sure to check my key re-bindings or aliases).

Some more common actions (read their docstrings for further help):

| Command         | Key chord | VC-dir key |
|-----------------+-----------+------------|
| vc-update       | C-x v +   | +          |
| vc-push         | C-x v P   | P          |
| vc-log-incoming | C-x v I   | I          |
| vc-log-outgoing | C-x v O   | O          |

Based on these (and there are more), you can already see how VC may be
used as your main tool for version control, from committing changes, to
pulling/pushing from/to a remote, viewing commit logs, etc.  It depends
on your needs and preferences.  Run =C-x v C-h= to get a full list of the
possible commands.  Read the docstring of each command for further
information.  Then in each of the various VC modes try =C-h m= for further
help.  Also consult the manual and make liberal use of =C-h f= or =C-h v=.

Changes to all tracked files are highlighted in the fringe thanks to the
=diff-hl= package which is [[#h:5b71e71f-353f-4290-951b-3fc575c0fcba][defined elsewhere in this document]] (as I
consider it an "interface" element).  Any rules that control the
placement of VC-related (and other) buffers are defined in the section
on [[#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][window rules and basic tweaks]] (specifically, refer to the variable
=display-buffer-alist=).

Also watch my [[https://protesilaos.com/codelog/2020-03-30-emacs-intro-vc/][Introduction to the Emacs Version Control framework]]
(2020-03-30).

*Careful with the keybindings* I define.  Many of them do other things by
default and /I might still review them further/.  When in doubt, stick
with the defaults.

#+begin_src emacs-lisp
(use-package vc
  :config
  (setq vc-find-revision-no-save t)
  (require 'log-view)                   ; needed for the key bindings
  :bind (("C-x v b" . vc-retrieve-tag)  ; "branch" switch
         ("C-x v t" . vc-create-tag)
         ("C-x v f" . vc-log-incoming)  ; the actual git fetch
         ("C-x v F" . vc-update)        ; "F" because "P" is push
         ("C-x v d" . vc-diff)
         (:map log-view-mode-map
               ("<tab>" . log-view-toggle-entry-display)
               ("<return>" . log-view-find-revision)
               ("s" . vc-log-search)
               ("o" . vc-log-outgoing)
               ("f" . vc-log-incoming)
               ("F" . vc-update)
               ("P" . vc-push))))

(use-package vc-dir
  :config
  (defun prot/vc-dir-project ()
    "Unconditionally display `vc-diff' for the current project."
    (interactive)
    (vc-dir (vc-root-dir)))
  :bind (("C-x v p" . prot/vc-dir-project)
         :map vc-dir-mode-map
         ("b" . vc-retrieve-tag)
         ("t" . vc-create-tag)
         ("o" . vc-log-outgoing)
         ("f" . vc-log-incoming) ; replaces `vc-dir-find-file' (use RET)
         ("F" . vc-update)       ; symmetric with P: `vc-push'
         ("d" . vc-diff)         ; align with D: `vc-root-diff'
         ("k" . vc-dir-clean-files)))

(use-package vc-git
  :config
  (setq vc-git-diff-switches "--patch-with-stat")
  (setq vc-git-print-log-follow t))

(use-package vc-annotate
  :config
  (setq vc-annotate-display-mode 'scale) ; scale to oldest
  :bind (("C-x v a" . vc-annotate)       ; `vc-update-change-log' is not in git
         :map vc-annotate-mode-map
         ("<tab>" . vc-annotate-toggle-annotation-visibility)))
#+end_src

**** Diff-mode

This covers the standard =diff-mode=, which I use when interfacing with
the built-in Version Control framework (see the [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][section on VC]]), but also
find while browsing various newsgroups via Gnus (see [[#h:5ad80664-3163-4d9d-be65-462637d77903][email settings]]).

Overview of these tweaks:

+ Always start the buffer in a read-only state.  A typo will mess things
  up when trying to apply a patch.
+ After a applying a diff hunk move on to the next one.
+ Update hunk headers automatically following an edit to the diff.
+ Do not show word-wise ("refined") changes upon activation.  I prefer
  to do so manually with =C-c C-b= for the current diff hunk.  All such
  highlights are removed if you generate the buffer again (with =g= as
  expected) and the default is to not show word-wise changes.
+ Do not prettify headers.  I like the standard "patch" looks.
+ Do not do any further syntax highlighting.  This is not the place to
  check your pretty code, plus it will most likely render colours highly
  inaccessible.

Basics for =diff-mode= buffers (as always you can learn more about the
current buffer's major mode with =C-h m=---read [[#h:83730fe8-d917-4d94-96f4-bbc5c900fe38][How do you learn Emacs?]] in
the FAQ below):

+ =C-c C-c= or =M-o= takes you to the point of the changes in the source
  file.  If you run this of the diff hunk's heading, you go to the
  beginning of the context.  But if you place the point somewhere inside
  of the diff's added changes or context, you will visit that exact
  position in the original file (does not work for removed text because
  technically it does not exist).  Awesome feature!
+ When working with patches to source code, which are distributed
  e.g. via email, you can apply the current hunk with =C-c C-a= or test
  for compatibility with =C-c C-t=.  This is a nice way to easily merge
  contributions of from others, without having to go through the
  workflow of some proprietary Git/Version-Control forge.
+ By default =C-c C-n= offers a convenience wrapper for Emacs' narrowing
  commands (such as =C-x n n= for =narrow-to-region=.  The standard is to
  narrow to the current diff hunk.  With the =C-u= prefix it will narrow
  to the current file instead (obviously this only makes sense when
  inspecting a multi-file set of changes).  If you use the default, you
  must manually exit narrowing with the standard =C-x n w=, but for this
  case I prefer =prot/diff-restrict-view-dwim= which will widen the view
  when narrowing is already in effect, else narrow as intended (I bind
  it to =C-c C-n= to replace the original).
+ With =prot/diff-buffer-with-file= I have a simple wrapper around a
  built-in command that compares a buffer to its underlying file.  This
  compares the changes made since the last save and my wrapper is about
  picking the current buffer directly.  If there are no differences,
  then the command with run =vc-diff= instead.  Note that in my
  configurations for the [[*Generic version control (VC) framework][Generic version control (VC) framework]], I remap
  the keys that pertain to diffs.
+ With =M-n= and =M-p= you move between hunks.  With =M-}= and =M-{= or =M-N=, =M-P=
  do the same between files.

#+begin_src emacs-lisp
(use-package diff
  :config
  (setq diff-default-read-only t)
  (setq diff-advance-after-apply-hunk t)
  (setq diff-update-on-the-fly t)
  ;; The following are from Emacs 27.1
  (setq diff-refine nil)
  (setq diff-font-lock-prettify nil)
  (setq diff-font-lock-syntax nil)

  (defun prot/diff-buffer-with-file (&optional arg)
    "Compare buffer to its file, else run `vc-diff'.
With \\[universal-argument] also enable highlighting of word-wise
changes, local to the current buffer."
    (interactive "P")
    (let ((buf nil))     ; this method will "fail" if multi diff buffers
      (if (buffer-modified-p)
          (progn
            (diff-buffer-with-file (current-buffer))
            (setq buf "*Diff*"))
        (vc-diff)
        (setq buf "*vc-diff*"))
      (when arg
        (with-current-buffer (get-buffer buf)
          (setq-local diff-refine 'font-lock)))))

  (defun prot/diff-restrict-view-dwim (&optional arg)
    "Use `diff-restrict-view', or widen when already narrowed.
By default the narrowing effect applies to the focused diff hunk.
With \\[universal-argument] do it for the current file instead."
    (interactive "P")
    (when (derived-mode-p 'diff-mode)
      (if (buffer-narrowed-p)
          (progn
            (widen)
            (message "Widened the view"))
        (if arg
            (progn
              (diff-restrict-view arg)
              (message "Narrowed to file"))
          (diff-restrict-view)
          (message "Narrowed to diff hunk")))))

  ;; `prot/diff-buffer-with-file' replaces the default for `vc-diff'
  ;; (which I bind to another key---see previous section).
  :bind (("C-x v =" . prot/diff-buffer-with-file)
         :map diff-mode-map
         ("C-c C-n" . prot/diff-restrict-view-dwim)))
#+end_src

**** Commit log editing

The =log-edit= library defines a set of general commands that we can use
to, inter alia, commit changes to Git, using the surprisingly powerful
[[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][built-in Version Control (VC) framework]].

Overview of the following tweaks:

+ While editing a commit message, only prompt for confirmation if the
  list of files has changed since the beginning of the editing session.
+ Once the commit is done, remove its buffer.
+ Always add a newline.
+ Do not offer to manually write an =Author:= header.  Though this can be
  useful if someone sends a patch.

Also make sure to read the guide for [[https://chris.beams.io/posts/git-commit/][writing a Git commit message]].  I
always use =auto-fill-mode= to wrap lines to the value of =fill-column= (see
[[#h:c392fef1-17b7-4cc0-b0e2-2b3edd0eed3c][relevant configs]]).

#+begin_src emacs-lisp
(use-package log-edit
  :config
  (setq log-edit-confirm 'changed)
  (setq log-edit-keep-buffer nil)
  (setq log-edit-require-final-newline t)
  (setq log-edit-setup-add-author nil))
#+end_src

** Interactive git front-end (Magit)

As noted in the [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][section on the built-in Version Control framework]] I use
Magit for easy access to the /advanced features of Git/.  While I rely on
the built-in tools for all day-to-day operations.

Magit offers a modal interface where the full power of =git= is neatly
organised in sets of keys that are directly accessible without holding
down any modifiers.

While inside the =magit-status= buffer, hit =?= to produce a transient menu
with the possible vectors to action.  Do it again inside each of the
Magit buffers to view the keys that work for their context.

Consider viewing my [[https://protesilaos.com/codelog/2020-04-04-emacs-intro-magit/][Introduction to Magit]] (2020-04-04) for how to stage
diffs, commit changes, view logs, create branches, and so on.

**** Base Magit settings

#+begin_src emacs-lisp
(use-package magit
  :ensure
  :bind ("C-c g" . magit-status))
#+end_src

**** Magit commits

#+begin_src emacs-lisp
(use-package git-commit
  :after magit
  :config
  (setq git-commit-summary-max-length 50)
  (setq git-commit-known-pseudo-headers
        '("Signed-off-by"
          "Acked-by"
          "Modified-by"
          "Cc"
          "Suggested-by"
          "Reported-by"
          "Tested-by"
          "Reviewed-by"))
  (setq git-commit-style-convention-checks
        '(non-empty-second-line
          overlong-summary-line)))
#+end_src

**** Magit diffs
The settings below are for the diff screens that Magit produces.  I just
want to highlight changes within a line, not just the line itself.  I
enable it only for the focused hunk (there is an option for ='all=).

#+begin_src emacs-lisp
(use-package magit-diff
  :after magit
  :config
  (setq magit-diff-refine-hunk t))
#+end_src

**** Magit repo list

When maintaining a number of projects, it sometimes is necessary to
produce a full list of them with their corresponding Magit status.  That
way you can determine very quickly which repositories need to be
examined further.

#+begin_src emacs-lisp
(use-package magit-repos
  :after magit
  :commands magit-list-repositories
  :config
  (setq magit-repository-directories
        '(("~/Git/Projects" . 1))))
#+end_src

* Directory, buffer, window management
** Dired (directory editor, file manager)

The directory editor abbreviated as "Dired" (which I pronounce like
"tired", "mired", etc.) is a built-in tool that performs file management
operations inside of an Emacs buffer.  It is simply superb!  I use it
daily for a number of tasks.

You can interactively copy, move (rename), symlink, delete files and
directories, handle permissions, compress or extract archives, run shell
commands, combine Dired with regular editing capabilities as part of a
keyboard macro, search[+replace] across multiple files, encrypt/decrypt
files, and more.  Combine that with the possibility of matching items
with regular expressions or creating an editable Dired buffer and you
have everything you need to maximise your productivity.

Check some of my videos:

+ [[https://protesilaos.com/codelog/2019-08-12-emacs-dired-tweaks/][Dired tweaks and refinements]] (2019-08-12).
+ [[https://protesilaos.com/codelog/2019-09-03-emacs-dired-macros/][Use Dired and keyboard macros]] (2019-09-03).
+ [[https://protesilaos.com/codelog/2019-09-19-dired-narrow/][Techniques to narrow Dired]] (2019-09-19).
+ [[https://protesilaos.com/codelog/2019-11-16-emacs-dired-chmod/][Change multi-file permissions with Dired]] (2019-11-16).
+ [[https://protesilaos.com/codelog/2019-11-13-emacs-bongo-music/][Music management with Dired and Bongo]] (2019-11-13).
+ [[https://protesilaos.com/codelog/2019-11-18-emacs-dired-bongo/][Dired+Bongo and macros to handle music playlists]] (2019-11-18).
+ [[https://protesilaos.com/codelog/2019-12-08-emacs-multi-replace/][Search and replace across multiple files (not Dired-specific)]] (2019-12-08).

*** Base settings for Dired
   :PROPERTIES:
   :CUSTOM_ID: h:751a310d-c63e-461c-a6e1-dfdfdb01cb92
   :END:

The options here are meant to do the following:

+ Copy and delete recursively.  Do not ask about it.
+ Search only file names while point is there, else the rest (useful
  when using the detailed view).
+ Deletion sends items to the system's Trash, making it safer than the
  standard =rm=.
+ Prettify output.  Sort directories first.  Show dotfiles first.  Omit
  implicit directories (the single and double dots).  Use human-readable
  size units.  There are also options for tweaking the behaviour of
  =find-name-dired=, in the same spirit.  To learn everything about
  these switches, you need to read the manpage of =ls=.  You can do it
  with =M-x man RET ls=.
+ Hide all the verbose details by default (permissions, size, etc.).
  These can easily be toggled on using the left parenthesis =(= inside a
  dired buffer.  Also enable highlighting of the current line, which
  makes it even easier to spot the current item (I do not enable this
  globally, because I only want it for per-line interfaces, such as
  Dired's, but not for per-character ones, such as text editing).
+ While having two dired buffers side-by-side, the rename and copy
  operations of one are easily propagated to the other.  Dired is smart
  about your intentions and uses the adjacent Dired buffer's path as a
  prefix when performing such actions.
+ For Emacs 27.1, Dired can automatically create destination directories
  for its copy and remove operations.  So you can, for example, rename
  =file= to =/non-existent-path/file= and you will get what you want right
  away.
+ For Emacs 27.1, renaming a file of a version-controlled repository
  (git) will be done using the appropriate VC mechanism.
+ Let the relevant =find= commands use case-insensitive names.
+ Enable asynchronous mode.  This is subject to change, as I need to
  test it a bit more.

Note that =dired-listing-switches= and =find-ls-option= are configured to
show hidden directories and files /before/ their non-hidden counterparts.
If you want to reverse this order, you must append the =-X= option (such
as =-AFXhlv --group-directories-first=).

The commands with the =contrib/= prefix in =dired-aux= are copied from the
[[https://github.com/oantolin/emacs-config][Emacs configurations of Omar Antolín Camarena]].  They let you insert the
path of a bookmarked directory while performing an action such as
copying and renaming/moving a file.  While my =prot/dired-fd-*= are
conceptually similar to functions in [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][projects and directory trees]] as
well as the ones in [[#h:06290f9c-491c-45b2-b213-0248f890c83d][the Ibuffer section]].

#+begin_src emacs-lisp
  (use-package dired
    :config
    (setq dired-recursive-copies 'always)
    (setq dired-recursive-deletes 'always)
    (setq delete-by-moving-to-trash t)
    (setq dired-listing-switches
	  "-AGFhlv --group-directories-first --time-style=long-iso")
    (setq dired-dwim-target t)
    ;; Note that the the syntax for `use-package' hooks is controlled by
    ;; the `use-package-hook-name-suffix' variable.  The "-hook" suffix is
    ;; not an error of mine.
    :hook ((dired-mode-hook . dired-hide-details-mode)
	   (dired-mode-hook . hl-line-mode)))

  (use-package dired-aux
    :config
    (setq dired-isearch-filenames 'dwim)
    ;; The following variables were introduced in Emacs 27.1
    (setq dired-create-destination-dirs 'ask)
    (setq dired-vc-rename-file t)

    ;; TODO defmacro to avoid duplication of code in `fd' functions
    ;; TODO how can a defmacro produce named functions that are then
    ;; mapped to keys?
    (defun prot/dired-fd-dirs (&optional arg)
      "Search for directories in VC root or PWD.
  With \\[universal-argument] put the results in a `dired' buffer.
  This relies on the external 'fd' executable."
      (interactive "P")
      (let* ((vc (vc-root-dir))
	     (dir (expand-file-name (if vc vc default-directory)))
	     (regexp (read-regexp
		      (concat "Subdirectories matching REGEXP in "
			      (propertize dir 'face 'bold)
			      ": ")))
	     (names (process-lines "fd" "-i" "-H" "-a" "-t" "d" "-c" "never" regexp dir))
	     (buf "*FD Dired*"))
	(if names
	    (if arg
		(dired (cons (generate-new-buffer-name buf) names))
	      (icomplete-vertical-do ()
		(find-file
		 (completing-read (concat
				   "Files or directories matching "
				   (propertize regexp 'face 'success)
				   (format " (%s)" (length names))
				   ": ")
				  names nil t)))))
	(user-error (concat "No matches for " "«" regexp "»" " in " dir))))

    (defun prot/dired-fd-files-and-dirs (&optional arg)
      "Search for files and directories in VC root or PWD.
  With \\[universal-argument] put the results in a `dired' buffer.
  This relies on the external 'fd' executable."
      (interactive "P")
      (let* ((vc (vc-root-dir))
	     (dir (expand-file-name (if vc vc default-directory)))
	     (regexp (read-regexp
		      (concat "Files and dirs matching REGEXP in "
			      (propertize dir 'face 'bold)
			      ": ")))
	     (names (process-lines "fd" "-i" "-H" "-a" "-t" "d" "-t" "f" "-c" "never" regexp dir))
	     (buf "*FD Dired*"))
	(if names
	    (if arg
		(dired (cons (generate-new-buffer-name buf) names))
	      (icomplete-vertical-do ()
		(find-file
		 (completing-read (concat
				   "Files and directories matching "
				   (propertize regexp 'face 'success)
				   (format " (%s)" (length names))
				   ": ")
				  names nil t)))))
	(user-error (concat "No matches for " "«" regexp "»" " in " dir))))

    (defun contrib/cdb--bookmarked-directories ()
      (bookmark-maybe-load-default-file)
      (cl-loop for (name . props) in bookmark-alist
	       for fn = (cdr (assq 'filename props))
	       when (and fn (string-suffix-p "/" fn))
	       collect (cons name fn)))

    (defun contrib/cd-bookmark (bm)
      "Insert the path of a bookmarked directory."
      (interactive
       (list (let ((enable-recursive-minibuffers t))
	       (completing-read
		"Directory: " (contrib/cdb--bookmarked-directories) nil t))))
      (when (minibufferp)
	(delete-region (minibuffer-prompt-end) (point-max)))
      (insert (cdr (assoc bm (contrib/cdb--bookmarked-directories)))))
    :bind (("M-s d" .  prot/dired-fd-dirs)
	   ("M-s z" . prot/dired-fd-files-and-dirs)
	   :map dired-mode-map
	   ("C-+" . dired-create-empty-file)
	   ("M-s f" . nil)
	   :map minibuffer-local-filename-completion-map
	   ("C-c d" . contrib/cd-bookmark)))

  (use-package find-dired
    :after dired
    :config
    (setq find-ls-option
	  '("-ls" . "-AGFhlv --group-directories-first --time-style=long-iso"))
    (setq find-name-arg "-iname"))

  (use-package async :ensure)

  (use-package dired-async
    :after (dired async)
    :hook (dired-mode-hook . dired-async-mode))
#+end_src

*Pro tip* while renaming or copying a file, =M-n= will return its original
name, thus allowing you to easily {pre,ap}pend to it.  This leverages an
intriguing concept of Emacs' design called "future history" (because =M-p=
goes back to your previous entries).  The notion of the future history,
when applied, is basically an educated guess of what the user would want
to do in the current context, given that they are not searching through
their previous actions.

**** TODO extend core Dired [1/3]
     :PROPERTIES:
     :CUSTOM_ID: h:f351058c-ea25-4ec3-88ce-2df6757fc193
     :END:
***** DONE front-end for `fd' executable
      CLOSED: [2020-05-30 Sat 20:17]
      :PROPERTIES:
      :CUSTOM_ID: h:00db9952-8a32-4142-8f62-dc275481e5a6
      :END:
***** TODO better handling of `xdg-open'
      :PROPERTIES:
      :CUSTOM_ID: h:b622cd06-14e6-4bdf-8730-b1a659591d4a
      :END:
***** TODO combine arbitrary dirs with selection
      :PROPERTIES:
      :CUSTOM_ID: h:bac59cd7-af79-43f5-89e4-520080817a61
      :END:
*** Narrowed dired
    :PROPERTIES:
    :CUSTOM_ID: h:affb6142-6216-43b6-9d66-e7b18d65e79e
    :END:

The standard way to produce a Dired buffer with only a handful of files
is to mark them, either manually or with =% m=, then toggle the mark with
=t=, and then remove (just from the view) everything with =k=.  This will
leave you with only the files you need to focus on.  With =g= you get back
to the unfiltered listing.

For dynamic filtering, use this package.  It offers several commands,
but I find that I only ever need to narrow by a regular expression
(check the source code for all of them =M-x find-library dired-narrow=).

#+begin_src emacs-lisp
(use-package dired-narrow
  :ensure
  :after dired
  :config
  (setq dired-narrow-exit-when-one-left t)
  (setq dired-narrow-enable-blinking t)
  (setq dired-narrow-blink-time 0.3)
  :bind (:map dired-mode-map
         ("/" . dired-narrow-regexp)))
#+end_src

*** wdired (writable dired)
    :PROPERTIES:
    :CUSTOM_ID: h:ab318722-fe96-4044-8811-f04f2ed74c06
    :END:

This is the editable state of a dired buffer.  You can access it with
=C-x C-q=.  Write changes to files or directories, as if it were a
regular buffer, then confirm them with =C-c C-c=.

+ While in writable state, allow the changing of permissions.
+ While renaming a file, any forward slash is treated like a directory
  and *is created directly* upon successful exit.

#+begin_src emacs-lisp
(use-package wdired
  :after dired
  :commands wdired-change-to-wdired-mode
  :config
  (setq wdired-allow-to-change-permissions t)
  (setq wdired-create-parent-directories t))
#+end_src

*** peep-dired (file previews including images)
    :PROPERTIES:
    :CUSTOM_ID: h:a90fb337-3cce-438a-a209-82b7eb42605f
    :END:

By default, dired does not show previews of files, while =image-dired=
is intended for a different purpose.  We just want to toggle the
behaviour while inside a regular dired buffer.

#+begin_src emacs-lisp
(use-package peep-dired
  :ensure
  :after dired
  :config
  (setq peep-dired-cleanup-on-disable t)
  (setq peep-dired-enable-on-directories nil)
  (setq peep-dired-ignored-extensions
        '("mkv" "webm" "mp4" "mp3" "ogg" "iso"))
  :bind (:map dired-mode-map
              ("P" . peep-dired)))
#+end_src

*** image-dired (image thumbnails and previews)
    :PROPERTIES:
    :CUSTOM_ID: h:30e647cb-aee5-45d9-93b4-dc4e855fd0a6
    :END:

This tool offers facilities for generating thumbnails out of a selection
of images and displaying them in a separate buffer.  An external program
is needed for converting the images into thumbnails: =imagemagick=.  Other
useful external packages are =optipng= and =sxiv=.  The former is for
operating on PNG files, while the latter is a lightweight image viewer.

I feel this process is a bit cumbersome and can be very slow if you try
to generate lots of images at once.  The culprit is the image converter.

#+begin_src emacs-lisp
(use-package image-dired
  :config
  (setq image-dired-external-viewer "xdg-open")
  (setq image-dired-thumb-size 80)
  (setq image-dired-thumb-margin 2)
  (setq image-dired-thumb-relief 0)
  (setq image-dired-thumbs-per-row 4)
  :bind (:map image-dired-thumbnail-mode-map
              ("<return>" . image-dired-thumbnail-display-external)))
#+end_src

*** dired-subtree (tree-style view/navigation)
    :PROPERTIES:
    :CUSTOM_ID: h:6f25c4c1-c504-44e8-8fe5-280d780f0897
    :END:

Tree-style navigation means that the subdirectories of the current Dired
buffer can be expanded and contracted in place.  It then is possible to
perform the same kind of folding on their subdirectories, and so on.

This is, in my opinion, a far more intuitive interaction than the
default way of inserting subdirectories in the current buffer below
their parent (type =i= over the target dir).  There still are uses for
that technique, but tree-style navigation is easier for day-to-day
tasks.

What I have here:

+ The tab key will expand or contract the subdirectory at point.
+ =C-TAB= will behave just like org-mode handles its headings: hit it
  once to expand a subdir at point, twice to do it recursively, thrice
  to contract the tree.
+ I also have Shift-TAB for contracting the subtree /when the point is
  inside of it/.

#+begin_src emacs-lisp
(use-package dired-subtree
  :ensure
  :after dired
  :config
  (setq dired-subtree-use-backgrounds nil)
  :bind (:map dired-mode-map
              ("<tab>" . dired-subtree-toggle)
              ("<C-tab>" . dired-subtree-cycle)
              ("<S-iso-lefttab>" . dired-subtree-remove)))
#+end_src

*** dired-x (extra Dired functions)
    :PROPERTIES:
    :CUSTOM_ID: h:56cbacd7-1fe6-447c-a77f-645edbaa3c6c
    :END:

These are some additional features that are shipped with Emacs.  The one
I need the most is =dired-jump= and its "other window" variant.  These are
among my favourite commands.  They will always take you to the directory
that contains the current buffer.

'Jumping' works even when you are inside buffers that do not visit
files, such as Magit, Diff, or Eshell.  This is its most valuable
quality!  Edit a file then proceed to do some file management, then
invoke =previous-buffer= or =winner-undo= to go back to where you were (I
have a few key bindings for those in the [[#h:12591f89-eeea-4b12-93e8-9293504e5a12][Window configuration section]]).
Everything happens naturally.  Emacs' interconnectedness at its best!

I keep =dired-clean-confirm-killing-deleted-buffers= to =t= as a safety
mechanism: if a file is ever deleted by accident I can use its buffer to
restore it (never happened in practice).

With regard to binding keys, I choose to handle things myself.  There
has never been a case where I had to run =info= or =man= inside of a
directory listing and wished there was some keyboard shortcut readily
available.

While in =dired-mode=, if you need to open all marked files at once, you
can hit =F=.  It calls =dired-do-find-marked-files=.

#+begin_src emacs-lisp
(use-package dired-x
  :after dired
  :config
  (setq dired-clean-up-buffers-too t)
  (setq dired-clean-confirm-killing-deleted-buffers t)
  (setq dired-x-hands-off-my-keys t)
  (setq dired-bind-man nil)
  (setq dired-bind-info nil)

  (defun prot/dired-jump-extra (&optional arg)
    "Switch directories comprising context and bookmarks.
NEEDS REVIEW."
    (interactive "P")
    (let* ((vc (vc-root-dir))
           (buf-name (buffer-file-name))
           (path (if buf-name
                     buf-name
                   default-directory))
           (file (abbreviate-file-name path))
           (bookmarks (mapcar (lambda (b)
                                (cdr b))
                              (contrib/cdb--bookmarked-directories)))
           (collection (append bookmarks
                             (list (file-name-directory file)
                                   (when vc vc))))
           (files (cl-remove-if (lambda (f)
                                  (eq f nil))
                                collection)))
      (icomplete-vertical-do ()
        (dired
         (completing-read "Jump to context or bookmark: " files nil t)))))

  :bind (("C-c j" . prot/dired-jump-extra)
         ("C-x C-j" . dired-jump)
         ("s-j" . dired-jump)
         ("C-x 4 C-j" . dired-jump-other-window)
         ("s-J" . dired-jump-other-window)))
#+end_src

*** diredfl (more dired colours)
    :PROPERTIES:
    :CUSTOM_ID: h:26ddf3cb-60f0-4e06-8c03-523fc092b8e8
    :END:

This package defines a few more colours for Dired, especially while in
the detailed view.  My themes support it, as well as a ton of other
packages (see the [[#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6][section on my Modus themes]]).

#+begin_src emacs-lisp
(use-package diredfl
  :ensure
  :hook (dired-mode-hook . diredfl-mode))
#+end_src

*** dired-like view for the trash directory
    :PROPERTIES:
    :CUSTOM_ID: h:954adfb4-8f2c-4665-bb5b-e098926341b0
    :END:

=trashed= applies the principles of =dired= to the management of the user's
filesystem trash.  Use =C-h m= to see the docs and keybindings for its
major mode.

Basically, its interaction model is as follows:

- =m= to mark for some deferred action, such as =D= to delete, =R= to restore.
- =t= to toggle the status of all items as marked.  Use this without marks
  to =m= (mark) all items, then call a deferred action to operate on them.
- =d= to mark for permanent deletion.
- =r= to mark for restoration.
- =x= to execute these special marks.

#+begin_src emacs-lisp
(use-package trashed
  :ensure
  :config
  (setq trashed-action-confirmer 'y-or-n-p)
  (setq trashed-use-header-line t)
  (setq trashed-sort-key '("Date deleted" . t))
  (setq trashed-date-format "%Y-%m-%d %H:%M:%S"))
#+end_src

** Working with buffers

*** Unique names for buffers
    :PROPERTIES:
    :CUSTOM_ID: h:60a70340-49dc-4f45-b147-12a4141db42b
    :END:

These settings make it easier to work with multiple buffers.  When two
buffers have the same name, Emacs will try to disambiguate them by
displaying their unique path inside angled brackets.  With the addition
of =uniquify-strip-common-suffix= it will also remove the part of the
file system path they have in common.

All such operations are reversed once an offending buffer is removed
from the list, allowing Emacs to revert to the standard of displaying
only the buffer's name.

#+begin_src emacs-lisp
(use-package uniquify
  :config
  (setq uniquify-buffer-name-style 'post-forward-angle-brackets)
  (setq uniquify-strip-common-suffix t)
  (setq uniquify-after-kill-buffer-p t))
#+end_src

**** TODO make uniquify better for Help, Info buffers
     :PROPERTIES:
     :CUSTOM_ID: h:d715be45-2a02-4202-80ea-5df4fd2056fa
     :END:
*** Ibuffer and extras (dired-like buffer list manager)
    :PROPERTIES:
    :CUSTOM_ID: h:06290f9c-491c-45b2-b213-0248f890c83d
    :END:

=ibuffer= is a built-in replacement for =list-buffers= that allows for
fine-grained control over the buffer list.  For this reason I bind it to
=C-x C-b=.

Overview of its features:

- mark and delete buffers same way you do in =dired= (see the previous
  sections on [[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][dired (directory editor, file manager)]]);
- mark by a predicate, such as name, major mode, etc.;
- sort buffers by name, filesystem path, major mode, size;
- run =occur= on the marked buffers (remember: Occur produces a buffer
  that you can edit once you enable the editable state with =e=);
- run =query-replace= on marked buffers or its regular-expression-aware
  equivalent.

Run the universal help command for major mode documentation (=C-h m=)
while inside =ibuffer= to get a detailed list of all available commands
and their key bindings.

With regard to the following package declaration, these are my tweaks to
the default behaviour and presentation:

+ Prompt for confirmation only when deleting a modified buffer.
+ Hide the summary.
+ Do not open on the other window (not focused window).
+ Do not show empty filter groups.
+ Do not cycle movements.  So do not go to the top when moving downward
  at the last item on the list.

Also watch my [[https://protesilaos.com/codelog/2020-04-02-emacs-intro-ibuffer/][introduction to Ibuffer]] (2020-04-02).

Now some extras after I published that video: =prot/buffers-major-mode=
and =prot/buffers-vc-root= will produce a filtered list based on the
current buffer's major mode or root version-control directory
respectively.  Their standard mode of interaction is through minibuffer
completions (see [[#h:07e173ea-e7ed-4fc0-ba3c-e44b403359a7][Minibuffer essentials and Icomplete]]).  With a prefix
argument =C-u= they switch to a dedicated Ibuffer view instead.

For those two I received help from Omar Antolín Camarena with regard to
the use of =read-buffer= and the =lambda= passed to it: my prototype was
using the generic =completing-read= with =cl-remove-if-not= for filtering
the list of candidates (all possible errors are my own).  The upside of
using Omar's approach is that it informs other tools that this kind of
completion concerns buffers, so they can adapt accordingly.  This is
done, for example, by Omar's powerful =embark= package (see section on
[[#h:e97988bc-fd77-4dca-b74a-0897087624bd][Embark (actions for completion candidates)]]).

I consider these two commands to be conceptually related to what I have
defined in [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Completion for projects and directory trees]].  The key chords
follow the same pattern, with the =M-s= prefix being considered an entry
point for "advanced search" methods, inspired by the default for =occur=
(=M-s o=) as well as a few others.

#+begin_src emacs-lisp
(use-package ibuffer
  :config
  (setq ibuffer-expert t)
  (setq ibuffer-display-summary nil)
  (setq ibuffer-use-other-window nil)
  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-movement-cycle nil)
  (setq ibuffer-default-sorting-mode 'filename/process)
  (setq ibuffer-use-header-line t)
  (setq ibuffer-default-shrink-to-minimum-size nil)
  (setq ibuffer-formats
        '((mark modified read-only locked " "
                (name 30 30 :left :elide)
                " "
                (size 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " " filename-and-process)
          (mark " "
                (name 16 -1)
                " " filename)))
  (setq ibuffer-saved-filter-groups nil)

  (defun prot/buffers-major-mode (&optional arg)
    "Select buffers that match the current buffer's major mode.
With \\[universal-argument] produce an `ibuffer' filtered
accordingly.  Else use standard completion."
    (interactive "P")
    (let* ((major major-mode)
           (prompt "Buffers for ")
           (mode-string (format "%s" major))
           (mode-string-pretty (propertize mode-string 'face 'success)))
      (if arg
          (ibuffer t (concat "*" prompt mode-string "*")
                   (list (cons 'used-mode major)))
        (switch-to-buffer
         (read-buffer
          (concat prompt mode-string-pretty ": ") nil t
          (lambda (pair) ; pair is (name-string . buffer-object)
            (with-current-buffer (cdr pair) (derived-mode-p major))))))))

  (defun prot/buffers-vc-root (&optional arg)
    "Select buffers that match the present `vc-root-dir'.
With \\[universal-argument] produce an `ibuffer' filtered
accordingly.  Else use standard completion.

When no VC root is available, use standard `switch-to-buffer'."
    (interactive "P")
    (let* ((root (vc-root-dir))
           (prompt "Buffers for VC ")
           (vc-string (format "%s" root))
           (vc-string-pretty (propertize vc-string 'face 'success)))
      (if root
          (if arg
              (ibuffer t (concat "*" prompt vc-string "*")
                       (list (cons 'filename (expand-file-name root))))
            (switch-to-buffer
             (read-buffer
              (concat prompt vc-string-pretty ": ") nil t
              (lambda (pair) ; pair is (name-string . buffer-object)
                (with-current-buffer (cdr pair) (string= (vc-root-dir) root))))))
        (call-interactively 'switch-to-buffer))))

  :hook (ibuffer-mode-hook . hl-line-mode)
  :bind (("M-s b" . prot/buffers-major-mode)
         ("M-s v" . prot/buffers-vc-root)
         ("C-x C-b" . ibuffer)
         :map ibuffer-mode-map
         ("* f" . ibuffer-mark-by-file-name-regexp)
         ("* g" . ibuffer-mark-by-content-regexp) ; "g" is for "grep"
         ("* n" . ibuffer-mark-by-name-regexp)
         ("s n" . ibuffer-do-sort-by-alphabetic)  ; "sort name" mnemonic
         ("/ g" . ibuffer-filter-by-content)))
#+end_src

**** Ibuffer integration with VC (version control framework)
     :PROPERTIES:
     :CUSTOM_ID: h:fcb95193-4049-4ae3-92ae-13176606e165
     :END:

This package offers a few functions for operating on =ibuffer= items based
on their corresponding version control data.

To me the most common case is to establish filter groups on a
per-project basis with =ibuffer-vc-set-filter-groups-by-vc-root=.  This
makes it easier to get an overview of where each buffer belongs,
especially in cases where you have similar looking names.

In terms of functionality, filter groups allow for per-group actions:

+ Move between group headings with =M-n= and =M-p=.
+ Toggle the visibility of the group with =RET=, while the point is over
  the heading.
+ With point over a heading, =m= will mark all its buffers, while =d= will
  mark them for deletion (confirm the latter with =x=, same as with
  =dired=).

The above granted, I prefer to create such filter groups manually via a
convenient key binding, rather than calling the function through a
relevant hook.

Make sure to also read the section on [[#h:0e2fe4c7-9d4b-4570-a293-9a9629021ff7][version control tools]].

#+begin_src emacs-lisp
(use-package ibuffer-vc
  :ensure
  :after (ibuffer vc)
  :bind (:map ibuffer-mode-map
              ("/ V" . ibuffer-vc-set-filter-groups-by-vc-root)
              ("/ <deletechar>" . ibuffer-clear-filter-groups)))
#+end_src

*** Scratch buffers per-major-mode
    :PROPERTIES:
    :CUSTOM_ID: h:2695bfa4-89b4-4d7f-aa6e-8ef42f9177aa
    :END:

This package will produce a buffer that matches the major mode of the
one you are currently in.  Use it with =M-x scratch=.  Doing that with a
prefix argument (=C-u=) will prompt for a major mode instead.  Simple yet
super effective!

The =prot/scratch-buffer-setup= simply adds some text in the buffer and
renames it appropriately for the sake of easier discovery.

#+begin_src emacs-lisp
(use-package scratch
  :ensure
  :config
  (defun prot/scratch-buffer-setup ()
    "Add contents to `scratch' buffer and name it accordingly."
    (let* ((mode (format "%s" major-mode))
           (string (concat "Scratch buffer for: " mode "\n\n")))
      (when scratch-buffer
        (save-excursion
          (insert string)
          (goto-char (point-min))
          (comment-region (point-at-bol) (point-at-eol)))
        (next-line 2))
      (rename-buffer (concat "*Scratch for " mode "*") t)))
  :hook (scratch-create-buffer-hook . prot/scratch-buffer-setup)
  :bind ("C-c s" . scratch))
#+end_src

** Window configuration

I believe that Emacs' true power lies in its buffer management rather
than its multiplexing.  The latter becomes inefficient at scale, since
it tries to emulate the limitations of the real world, namely, the
placement of things on a desk.

By leveraging the power of the computer, we can use search methods to
easily reach any item.  There is no need to remain confined to the idea
of a finite space (screen real estate) that needs to be carefully
managed.

That granted, Emacs' multiplexing can be turned into a powerhouse as
well, covering everything from window placement rules, to the recording
of history and layouts, as well as directional or direct window
navigation.

The =prot/window-single-toggle= is based on [[https://gitlab.com/ambrevar/emacs-windower/-/blob/master/windower.el][Pierre Neidhardt's windower]].

#+begin_src emacs-lisp
(use-package emacs
  :config
  (defvar prot/window-configuration nil
    "Current window configuration.
Intended for use by `prot/window-monocle'.")

  (defun prot/window-single-toggle ()
    "Toggle between multiple windows and single window.
This is the equivalent of maximising a window.  Tiling window
managers such as DWM, BSPWM refer to this state as 'monocle'."
    (interactive)
    (if (one-window-p)
        (when prot/window-configuration
          (set-window-configuration prot/window-configuration))
      (setq prot/window-configuration (current-window-configuration))
      (delete-other-windows)))
  :bind ("s-m" . prot/window-single-toggle))
#+end_src

*** Window rules and basic tweaks

The =display-buffer-alist= and all other functions grouped together with
=prot/window-dired-vc-root-left= are considered *experimental and subject
to review*.  The former is intended as a rule-set for controlling the
display of windows.  While the latter serves as a series of tangible
examples of passing certain rules programmatically, in combination with
a few relevant extras.  The objective is to create a more intuitive
workflow where targeted buffer groups or types are always shown in a
given location, on the premise that predictability improves usability.

For each buffer action in =display-buffer-alist= we can define several
functions for selecting the appropriate window.  These are executed in
sequence, but my usage thus far suggests that a simpler method is just
as effective for my case.

Everything pertaining to buffer actions is documented at length in the
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html#Top][GNU Emacs Lisp Reference Manual]], currently corresponding to version
26.3.  Information can also be found via =C-h f display-buffer= and, for
my settings, =C-h f display-buffer-in-side-window=.

With regard to the contents of the =:bind= keyword of the =window= library,
most key combinations are complementary to the standard ones, such as
=C-x 1= becoming =s-1=, =C-x o= turning into =s-o= and the like.  They *do not
replace* the defaults: they just provide more convenient access to their
corresponding functions.  They all involve the Super key, following the
norms described in the [[#h:fbba4dea-9cc8-4e73-bffa-02aab10a6703][introductory note on the matter]].  Concerning the
=balance-windows-area= I find that it is less intrusive than the original
=balance-windows= normally bound to the same =C-x +=.

For a demo of the =display-buffer-alist= and the functions that
accompany it, watch my [[https://protesilaos.com/codelog/2020-01-07-emacs-display-buffer/][video on rules for buffer placement]]
(2020-01-07).

#+begin_src emacs-lisp
(use-package window
  :init
  (setq display-buffer-alist
        '(;; top side window
          ("\\*elfeed-mpv-output.*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . -1))
          ("\\*\\(Flycheck\\|Flymake\\|Package-Lint\\|vc-git :\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 0)
           (window-parameters . ((no-other-window . t))))
          ("\\*Messages.*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 1)
           (window-parameters . ((no-other-window . t))))
          ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\)\\*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 2)
           (window-parameters . ((no-other-window . t))))
          ;; bottom side window
          ("\\*\\(Output\\|Register Preview\\).*"
           (display-buffer-in-side-window)
           (window-width . 0.16)       ; See the :hook
           (side . bottom)
           (slot . -1)
           (window-parameters . ((no-other-window . t))))
          (".*\\*\\(Completions\\|Embark Live Occur\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . bottom)
           (slot . 0)
           (window-parameters . ((no-other-window . t))))
          ("^\\(\\*e?shell\\|vterm\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . bottom)
           (slot . 1))
          ;; left side window
          ("\\*Help.*"
           (display-buffer-in-side-window)
           (window-width . 0.20)       ; See the :hook
           (side . left)
           (slot . 0)
           (window-parameters . ((no-other-window . t))))
          ;; right side window
          ("\\*Faces\\*"
           (display-buffer-in-side-window)
           (window-width . 0.25)
           (side . right)
           (slot . 0)
           (window-parameters . ((no-other-window . t)
                                 (mode-line-format . (" "
                                                      mode-line-buffer-identification)))))
          ("\\*Custom.*"
           (display-buffer-in-side-window)
           (window-width . 0.25)
           (side . right)
           (slot . 1))
          ;; bottom buffer (NOT side window)
          ("\\*\\vc-\\(incoming\\|outgoing\\).*"
           (display-buffer-at-bottom))
          ("\\*Embark Occur.*"
           (display-buffer-at-bottom))))
  (setq window-combination-resize t)
  (setq even-window-sizes 'height-only)
  (setq window-sides-vertical nil)
  ;; Note that the the syntax for `use-package' hooks is controlled by
  ;; the `use-package-hook-name-suffix' variable.  The "-hook" suffix is
  ;; not an error of mine.
  :hook ((help-mode-hook . visual-line-mode)
        (custom-mode-hook . visual-line-mode))
  :bind (("s-n" . next-buffer)
         ("s-p" . previous-buffer)
         ("s-o" . other-window)
         ("s-2" . split-window-below)
         ("s-3" . split-window-right)
         ("s-0" . delete-window)
         ("s-1" . delete-other-windows)
         ("s-5" . delete-frame)
         ("C-x +" . balance-windows-area)
         ("s-q" . window-toggle-side-windows)))

;; These are all experimental.  Just showcasing the power of passing
;; parameters to windows or frames.
(use-package emacs
  :commands (prot/window-dired-vc-root-left
             prot/make-frame-floating-with-current-buffer
             prot/display-buffer-at-bottom)
  :config
  (defun prot/window-dired-vc-root-left ()
    "Open root directory of current version-controlled repository
or the present working directory with `dired' and bespoke window
parameters.  This is meant as a proof-of-concept function,
illustrating how to leverage window rules to display a buffer,
plus a few concomitant extras."
    (interactive)
    (let ((dir (if (eq (vc-root-dir) nil)
                   (dired-noselect default-directory)
                 (dired-noselect (vc-root-dir)))))
      (display-buffer-in-side-window
       dir `((side . left)
             (slot . -1)
             (window-width . 0.16)
             (window-parameters . ((no-other-window . t)
                                   (no-delete-other-windows . t)
                                   (mode-line-format . (" "
                                                        mode-line-buffer-identification))))))
      (with-current-buffer dir
        (rename-buffer "*Dired-Side*")
        (setq-local window-size-fixed 'width)))
    (with-eval-after-load 'ace-window
      (when (boundp 'aw-ignored-buffers)
        (add-to-list 'aw-ignored-buffers "*Dired-Side*"))))

  (defun prot/make-frame-floating-with-current-buffer ()
    "Display the current buffer in a new floating frame.

This passes certain parameters to the newly created frame:

- use a different name than the default;
- use a graphical frame;
- do not display the minibuffer.

The name is meant to be used by the external rules of my tiling
window manager (BSPWM) to present the frame in a floating state."
    (interactive)
    (make-frame '((name . "my_float_window")
                  (window-system . x)
                  (minibuffer . nil))))

  (defun prot/display-buffer-at-bottom ()
    "Move the current buffer to the bottom of the frame.  This is
useful to take a buffer out of a side window.

The window parameters of this function are provided mostly for
didactic purposes."
    (interactive)
    (let ((buffer (current-buffer)))
      (with-current-buffer buffer
        (delete-window)
        (display-buffer-at-bottom
         buffer `((window-parameters . ((mode-line-format . (" "
                                                             mode-line-buffer-identification))))))))))
#+end_src

*** Window history (winner-mode)
    :PROPERTIES:
    :CUSTOM_ID: h:6b4f7792-6ccd-45d5-b262-01d200639072
    :END:

Winner is a built-in tool that keeps a record of buffer and window
layout changes.  It then allows us to move back and forth in the
history of said changes.  I have it enabled by default, while I assign
its two main functions to Super and the right/left arrow keys.

#+begin_src emacs-lisp
(use-package winner
  :hook (after-init-hook . winner-mode)
  :bind ("<s-right>" . winner-redo)
         ("<s-left>" . winner-undo))
#+end_src

Windmove is also built into Emacs.  It provides functions for selecting
a window in any of the cardinal directions.  I use the Vim keys while
holding down Super and Meta because other mnemonics-based actions
involving just Super or Meta are already occupied.

*** Tabs for window layouts and buffers (Emacs 27.1)
    :PROPERTIES:
    :CUSTOM_ID: h:63ad472f-c9c2-40ad-9675-1dc529487788
    :END:

Starting with version 27.1, Emacs has built-in support for two distinct
concepts of "tabs":

1. Work spaces that contain windows in any given layout.
2. A list of buffers presented as buttons at the top of the window.

The former, represented by the =tab-bar= library, is best understood as
the equivalent of "virtual desktops", as these are used in most desktop
environments or window managers.

The latter, implemented in =tab-line=, is the same as the tabs you are
used to in web browsers.  Each buffer is assigned to a single tab.
Clicking on the tab takes you to the corresponding buffer.

I do not need the =tab-line= as I find such tabs to be inefficient at
scale.  Finding a buffer through search mechanisms is generally faster:
it does not matter whether you have ten or a hundred buffers on the list
(unless, of course, they all have similar names in which case you are in
trouble either way---do not forget to check my [[#h:06290f9c-491c-45b2-b213-0248f890c83d][Ibuffer settings]]).

On the other hand, the work spaces (=tab-bar=) are very useful for
organising the various applications that are running inside of Emacs.
You can, for example, have your current project on tab (workspace) 1,
your email and news reader on 2, music on 3, and so on.  Of course, this
can also be achieved by using separate frames for each of these, though
I generally prefer working in a single frame (plus you can define a
window configuration or frameset in a register---see [[#h:6bdfe4d1-f97a-4d89-ab68-e87448a95fea][relevant section]]).

For me tabs are useful as groups of buffers in a given window
configuration.  I do not want a persistent bar with buttons that
introduces extra visual clutter.  Switching to tabs is done through
completion, specifically =prot/icomplete-tab-bar-select-tab=.  This
extends the configurations in my [[#h:07e173ea-e7ed-4fc0-ba3c-e44b403359a7][minibuffer essentials and Icomplete]].
Otherwise, we can use =tab-switcher= which produces a buffer with the
entire list, plus a basic command for marking an item for deletion (same
principle as with, e.g., =dired=).

All settings I configure here are meant to work in accordance with this
abstract conception of "tabs are work spaces".  Here are the main key
chords for =tab-bar= (they will all work properly if you keep the mode
active):

| Key     | Description                       |
|---------+-----------------------------------|
| C-x t b | Open a buffer in a new tab        |
| C-x t d | Open a directory in a new tab     |
| C-x t f | Open a file in a new tab          |
| C-x t 0 | Close current tab                 |
| C-x t 1 | Close all other tabs              |
| C-x t 2 | Open current buffer in new tab    |

These are consistent with the standard commands for handling windows and
accessing buffers/files in the "other window" (the =C-x 4 KEY= pattern).
There is also a command for giving a name to the current tab, accessed
via =C-x t r=, though I find I do not use it.

#+begin_src emacs-lisp
(use-package tab-bar
  :config
  (setq tab-bar-close-button-show nil)
  (setq tab-bar-close-last-tab-choice 'tab-bar-mode-disable)
  (setq tab-bar-close-tab-select 'recent)
  (setq tab-bar-new-tab-choice t)
  (setq tab-bar-new-tab-to 'right)
  (setq tab-bar-position nil)
  (setq tab-bar-show nil)
  (setq tab-bar-tab-hints nil)
  (setq tab-bar-tab-name-function 'tab-bar-tab-name-all)

  (tab-bar-mode -1)
  (tab-bar-history-mode -1)

  (defun prot/icomplete-tab-bar-tab-dwim ()
    "Do-What-I-Mean function for getting to a `tab-bar-mode' tab.
If no other tab exists, create one and switch to it.  If there is
one other tab (so two in total) switch to it without further
questions.  Else use completion to select the tab to switch to."
    (interactive)
    (let ((tabs (mapcar (lambda (tab)
                          (alist-get 'name tab))
                        (tab-bar--tabs-recent))))
      (cond ((eq tabs nil)
             (tab-new))
            ((eq (length tabs) 1)
             (tab-next))
            (t
             (icomplete-vertical-do ()
               (tab-bar-switch-to-tab
                (completing-read "Select tab: " tabs nil t)))))))

  :bind (("C-x t t" . prot/icomplete-tab-bar-tab-dwim)
         ("s-t" . prot/icomplete-tab-bar-tab-dwim)
         ("C-x t s" . tab-switcher)))

;; This is only included as a reference.
(use-package tab-line
  :disabled
  :commands (tab-line-mode global-tab-line-mode)
  :config
  (global-tab-line-mode -1))
#+end_src

**** TODO tab-line for groups that make sense, such as EWW
     :PROPERTIES:
     :CUSTOM_ID: h:4ac5ffc4-98a5-4eac-89eb-561dd069dff5
     :END:
*** Directional window motions (windmove)
    :PROPERTIES:
    :CUSTOM_ID: h:230d96c8-a955-4b82-844d-9de9a1b7c531
    :END:

While =C-x o= (=other-window=) is very useful when working with two or three
windows, it can become tiresome.  Thankfully, Emacs comes with a
built-in package to move to a window in the given direction.  I bind the
cardinal directions to Super+Ctrl plus the Vim keys (heresy!), with
aliases for the arrows you find on a standard keyboard's number pad.

The =windmove-create-window= specifies what should happen when trying to
move past the edge of the frame.  The idea with this is to allow it to
create a new window with the contents of the current buffer.  I tried it
for a while but felt that the times it would interfere with my layout
where more than those it would actually speed up my workflow.

#+begin_src emacs-lisp
(use-package windmove
  :config
  (setq windmove-create-window nil)     ; Emacs 27.1
  :bind (("C-s-k" . windmove-up)
         ("C-s-l" . windmove-right)
         ("C-s-j" . windmove-down)
         ("C-s-h" . windmove-left)
         ;; numpad keys clockwise: 8 6 2 4
         ("<kp-up>" . windmove-up)
         ("<kp-right>" . windmove-right)
         ("<kp-down>" . windmove-down)
         ("<kp-left>" . windmove-left)))
#+end_src
